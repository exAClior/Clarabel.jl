# find the maximum step length α≥0 so that
# q + α*dq stays in an exponential or power
# cone, or their respective dual cones.


# #-------------------------------------
# # primal-dual scaling
# #-------------------------------------

# # Implementation sketch
# # 1) only need to replace μH by W^TW, where
# #    W^TW is the primal-dual scaling matrix 
# #    generated by BFGS, i.e. W^T W*[z,\tilde z] = [s,\tile s]
# #   \tilde z = -f'(s), \tilde s = - f*'(z)

#additional basic kernel operations
function _kernel_mul_Hs_nonsymmetric!(
    y::AbstractVector{T},
    Hs::AbstractArray{T},
    x::AbstractVector{T},
    rng_cones::AbstractVector,
    n_shift::Cint,
    n_nonsymmetric::Cint
) where {T}

    i = (blockIdx().x-one(Cint))*blockDim().x+threadIdx().x

    if i <= n_nonsymmetric
        # update both gradient and Hessian for function f*(z) at the point z
        shift_i = i + n_shift
        rng_i = rng_cones[shift_i]
        @views Hsi = Hs[:,:,i]
        @views yi = y[rng_i]
        @views xi = x[rng_i]

        @inbounds for j = 1:3
            yi[j] =  Hsi[j,1]*xi[1] + Hsi[j,2]*xi[2] + Hsi[j,3]*xi[3]
        end

    end

    return nothing

end

@inline function mul_Hs_nonsymmetric!(
    y::AbstractVector{T},
    Hs::AbstractArray{T},
    x::AbstractVector{T},
    rng_cones::AbstractVector,
    n_shift::Cint,
    n_nonsymmetric::Cint
) where {T}

    kernel = @cuda launch=false _kernel_mul_Hs_nonsymmetric!(y, Hs, x, rng_cones, n_shift, n_nonsymmetric)
    config = launch_configuration(kernel.fun)
    threads = min(n_nonsymmetric, config.threads)
    blocks = cld(n_nonsymmetric, threads)

    kernel(y, Hs, x, rng_cones, n_shift, n_nonsymmetric; threads, blocks)
end

@inline function affine_ds_nonsymmetric!(
    ds::AbstractVector{T}, 
    s::AbstractVector{T},  
    rng_cones::AbstractVector,
    n_shift::Cint, 
    n_nonsymmetric::Cint
) where {T}
    CUDA.@allowscalar begin
        rng = rng_cones[n_shift+1].start:rng_cones[n_shift+n_nonsymmetric].stop
    end

    @. ds[rng] = s[rng]
end

@inline function Δs_from_Δz_offset_nonsymmetric!(
    out::AbstractVector{T}, 
    ds::AbstractVector{T}, 
    rng_cones::AbstractVector, 
    n_shift::Cint, 
    n_nonsymmetric::Cint
) where {T}
    CUDA.@allowscalar begin
        rng = rng_cones[n_shift + 1].start:rng_cones[n_shift + n_nonsymmetric].stop
    end
    @. out[rng] = ds[rng]
end

# use the dual scaling strategy
@inline function use_dual_scaling_gpu(
    Hs::AbstractArray{T},
    H_dual::AbstractArray{T},
    μ::T
) where {T}
    @inbounds for i = 1:9
        Hs[i] = μ*H_dual[i]
    end
end


# use the primal-dual scaling strategy
@inline function use_primal_dual_scaling_exp(
    s::AbstractVector{T},
    z::AbstractVector{T},
    grad::AbstractVector{T},
    Hs::AbstractArray{T},
    H_dual::AbstractArray{T}
) where {T}

    st  = grad
    δs  = @MVector T[0, 0, 0]
    tmp = @MVector T[0, 0, 0] #shared for δz, tmp, axis_z

    # compute zt,st,μt locally
    # NB: zt,st have different sign convention wrt Mosek paper
    zt = gradient_primal_exp(s)
    dot_sz = _dot_xy_gpu_3(z,s)
    μ = dot_sz/3
    μt = _dot_xy_gpu_3(zt,st)/3

    δz = tmp
    @inbounds for i in eachindex(st)
        δs[i] = s[i] + μ*st[i]
        δz[i] = z[i] + μ*zt[i]
    end    
    dot_δsz = _dot_xy_gpu_3(δs,δz)

    de1 = μ*μt-1
    de2 = _dot_xHy_gpu(zt,H_dual,zt) - 3*μt*μt

    # use the primal-dual scaling
    if (abs(de1) > sqrt(eps(T)) &&   # too close to central path
        abs(de2) > eps(T) &&         # for numerical stability
        dot_sz > zero(T) && 
        dot_δsz > zero(T))
       
        # compute t
        # tmp = μt*st - H_dual*zt
        @inbounds for i = 1:3
            tmp[i] = μt*st[i] - H_dual[i,1]*zt[1] - H_dual[i,2]*zt[2] - H_dual[i,3]*zt[3]
        end

        # Hs as a workspace
        # copyto!(Hs,H_dual)
        @inbounds for i = 1:9
            Hs[i] = H_dual[i]
        end
        @inbounds for i = 1:3
            @inbounds for j = 1:3
                Hs[i,j] -= st[i]*st[j]/3 + tmp[i]*tmp[j]/de2
            end
        end

        t = μ*_normHF(Hs)  #Frobenius norm

        # @assert dot_sz > 0
        # @assert dot_δsz > 0
        @assert t > 0

        # generate the remaining axis
        # axis_z = cross(z,zt)
        axis_z = tmp
        axis_z[1] = z[2]*zt[3] - z[3]*zt[2]
        axis_z[2] = z[3]*zt[1] - z[1]*zt[3]
        axis_z[3] = z[1]*zt[2] - z[2]*zt[1]
        _normalize!(axis_z)

        # Hs = s*s'/⟨s,z⟩ + δs*δs'/⟨δs,δz⟩ + t*axis_z*axis_z'
        @inbounds for i = 1:3
            @inbounds for j = i:3
                Hs[i,j] = s[i]*s[j]/dot_sz + δs[i]*δs[j]/dot_δsz + t*axis_z[i]*axis_z[j]
            end
        end
        # symmetrize matrix
        Hs[2,1] = Hs[1,2]
        Hs[3,1] = Hs[1,3]
        Hs[3,2] = Hs[2,3]

        return nothing
    else
        # Hs = μ*H_dual when s,z are on the central path
        use_dual_scaling_gpu(Hs,H_dual,μ)

        return nothing
    end
    
    return nothing
end

# use the primal-dual scaling strategy
@inline function use_primal_dual_scaling_pow(
    s::AbstractVector{T},
    z::AbstractVector{T},
    grad::AbstractVector{T},
    Hs::AbstractArray{T},
    H_dual::AbstractArray{T},
    α::T
) where {T}

    st  = grad
    δs  = @MVector T[0, 0, 0]
    tmp = @MVector T[0, 0, 0] #shared for δz, tmp, axis_z

    # compute zt,st,μt locally
    # NB: zt,st have different sign convention wrt Mosek paper
    zt = gradient_primal_pow(s,α)
    dot_sz = _dot_xy_gpu_3(z,s)
    μ = dot_sz/3
    μt = _dot_xy_gpu_3(zt,st)/3

    δz = tmp
    @inbounds for i in 1:3
        δs[i] = s[i] + μ*st[i]
        δz[i] = z[i] + μ*zt[i]
    end    
    dot_δsz = _dot_xy_gpu_3(δs,δz)

    de1 = μ*μt-1
    de2 = _dot_xHy_gpu(zt,H_dual,zt) - 3*μt*μt

    # use the primal-dual scaling
    if (abs(de1) > sqrt(eps(T)) &&   # too close to central path
        abs(de2) > eps(T) &&         # for numerical stability
        dot_sz > zero(T) && 
        dot_δsz > zero(T))
       
        # compute t
        # tmp = μt*st - H_dual*zt
        @inbounds for i = 1:3
            tmp[i] = μt*st[i] - H_dual[i,1]*zt[1] - H_dual[i,2]*zt[2] - H_dual[i,3]*zt[3]
        end

        # Hs as a workspace
        # copyto!(Hs,H_dual)
        @inbounds for i = 1:9
            Hs[i] = H_dual[i]
        end
        @inbounds for i = 1:3
            @inbounds for j = 1:3
                Hs[i,j] -= st[i]*st[j]/3 + tmp[i]*tmp[j]/de2
            end
        end

        t = μ*_normHF(Hs)  #Frobenius norm

        # @assert dot_sz > 0
        # @assert dot_δsz > 0
        @assert t > 0

        # generate the remaining axis
        # axis_z = cross(z,zt)
        axis_z = tmp
        axis_z[1] = z[2]*zt[3] - z[3]*zt[2]
        axis_z[2] = z[3]*zt[1] - z[1]*zt[3]
        axis_z[3] = z[1]*zt[2] - z[2]*zt[1]
        _normalize!(axis_z)

        # Hs = s*s'/⟨s,z⟩ + δs*δs'/⟨δs,δz⟩ + t*axis_z*axis_z'
        @inbounds for i = 1:3
            @inbounds for j = i:3
                Hs[i,j] = s[i]*s[j]/dot_sz + δs[i]*δs[j]/dot_δsz + t*axis_z[i]*axis_z[j]
            end
        end
        # symmetrize matrix
        Hs[2,1] = Hs[1,2]
        Hs[3,1] = Hs[1,3]
        Hs[3,2] = Hs[2,3]

        return nothing
    else
        # Hs = μ*H_dual when s,z are on the central path
        use_dual_scaling_gpu(Hs,H_dual,μ)

        return nothing
    end
    
end


# #------------------------------------------------------------
# # Numerical sub-routines for primal barrier computation
# #------------------------------------------------------------
# function _newton_raphson_onesided(x0::T,f0::Function,f1::Function) where {T}

#     #implements NR method from a starting point assumed to be to the 
#     #left of the true value.   Once a negative step is encountered 
#     #this function will halt regardless of the calculated correction.

#     iter = 0
#     x = x0

#     while iter < 100

#         iter += 1
#         dfdx  =  f1(x)  
#         dx    = -f0(x)/dfdx

#         if (dx < eps(T)) ||
#             (abs(dx/x) < sqrt(eps(T))) ||
#             (abs(dfdx) < eps(T))
#             break
#         end
#         x += dx
#     end
#     return x
# end

@inline function _dot_xHy_gpu(x::Union{AbstractVector{T}, NTuple{3,T}}, H::AbstractArray{T}, y::Union{AbstractVector{T}, NTuple{3,T}}) where {T} 
    val = zero(T)
    @inbounds for j in 1:3
        val += x[j]*(H[j,1]*y[1]+H[j,2]*y[2]+H[j,3]*y[3])
    end
    
    return val
end 

@inline function _normHF(H::AbstractArray{T}) where {T} 
    val = zero(T)
    @inbounds for j in 1:9
        val += H[j]*H[j]
    end
    
    return sqrt(val)
end 

@inline function _normalize!(x::AbstractVector{T}) where {T} 
    val = zero(T)
    @inbounds for j in 1:3
        val += x[j]*x[j]
    end
    normx = sqrt(val)
    @inbounds for j in 1:3
        x[j] /= normx
    end     
    return nothing
end 

@inline function _dot_xy_gpu_3(x::Union{AbstractVector{T}, NTuple{3,T}}, y::Union{AbstractVector{T}, NTuple{3,T}}) where {T} 
    val = x[1]*y[1] + x[2]*y[2] + x[3]*y[3]
    
    return val
end 